<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Award-Winning Cinematic CMRL Metro Experience</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            background: #9bd7f0;
            overflow-x: hidden;
            height: 500vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #webgl {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
            pointer-events: none;
            width: 100%;
            height: 100%;
        }

        #ui {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            color: white;
            text-align: center;
            text-shadow: 0 4px 15px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        h1 {
            font-size: 6vw;
            margin: 0;
            font-weight: 800;
            letter-spacing: 2px;
        }

        p {
            font-size: 2vw;
            opacity: 0.9;
            margin-top: 10px;
        }

        .shutter {
            position: fixed;
            left: 0;
            width: 100vw;
            height: 0vh;
            background: #000;
            z-index: 100;
            pointer-events: none;
        }

        #shutter-top {
            top: 0;
        }

        #shutter-bottom {
            bottom: 0;
        }

        #loading {
            position: fixed;
            inset: 0;
            background: #050505;
            color: #fff;
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2vw;
            letter-spacing: 4px;
            transition: opacity 1s ease-out;
        }
    </style>
</head>

<body>
    <div id="loading">GENERATING AWARD-WINNING REALISM...</div>
    <div id="ui">
        <h1>CHENNAI METRO</h1>
        <p>Scroll down to experience True Cinematic 3D</p>
    </div>

    <div class="shutter" id="shutter-top"></div>
    <div class="shutter" id="shutter-bottom"></div>

    <canvas id="webgl"></canvas>

    <!-- Core Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

    <!-- Post-Processing Modules -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <!-- GSAP for Smooth Scroll Timelines -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

    <script>
        gsap.registerPlugin(ScrollTrigger);

        // --- 1. CORE SETUP & POST-PROCESSING ---
        const canvas = document.getElementById('webgl');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x9bd7f0, 0.002);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 40, 150);
        camera.lookAt(0, 40, 0);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;

        // Unreal Bloom for glowing lights, sun bleed, and metallic glints
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.6; // Only deeply lit materials (metals, lights, sun) glow
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.8;
        composer.addPass(bloomPass);

        // Environment Map (HDRI equivalent) for Extreme Metal Reflections
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        const envCvs = document.createElement('canvas'); envCvs.width = 1024; envCvs.height = 512;
        const ctxEnv = envCvs.getContext('2d');
        const grad = ctxEnv.createLinearGradient(0, 0, 0, 512);
        grad.addColorStop(0, '#5fa0dc'); // Sky blue
        grad.addColorStop(0.4, '#ffffff'); // Light horizon
        grad.addColorStop(0.5, '#444444'); // Cityline
        grad.addColorStop(1, '#222222'); // Ground
        ctxEnv.fillStyle = grad; ctxEnv.fillRect(0, 0, 1024, 512);

        // Sun in the environment map (casts huge bloom reflection)
        ctxEnv.fillStyle = '#ffffff';
        ctxEnv.beginPath(); ctxEnv.arc(250, 150, 40, 0, Math.PI * 2); ctxEnv.fill();

        const envTex = new THREE.CanvasTexture(envCvs);
        const envTarget = pmremGenerator.fromEquirectangular(envTex);
        scene.environment = envTarget.texture;
        scene.background = envTarget.texture; // Sky matches reflections

        // --- 2. LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x445566, 0.4);
        scene.add(hemiLight);

        const sunLight = new THREE.DirectionalLight(0xfff5e6, 2.0); // Intense sun for bloom
        sunLight.position.set(200, 150, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 4096; // Ultra high-res shadows
        sunLight.shadow.mapSize.height = 4096;
        sunLight.shadow.camera.near = 10;
        sunLight.shadow.camera.far = 400;
        const shRange = 150;
        sunLight.shadow.camera.left = -shRange; sunLight.shadow.camera.right = shRange;
        sunLight.shadow.camera.top = shRange; sunLight.shadow.camera.bottom = -shRange;
        sunLight.shadow.bias = -0.0005;
        scene.add(sunLight);

        // --- 3. PROCEDURAL TEXTURES & MATERIALS ---
        function createBrushedMetal() {
            const cvs = document.createElement('canvas'); cvs.width = 1024; cvs.height = 1024;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#b0b5b9'; ctx.fillRect(0, 0, 1024, 1024); // Darker base for reflection contrast
            ctx.fillStyle = 'rgba(255,255,255,0.05)';
            for (let i = 0; i < 8000; i++) ctx.fillRect(Math.random() * 1024, Math.random() * 1024, Math.random() * 200 + 50, Math.random() * 2 + 1);
            ctx.fillStyle = 'rgba(0,0,0,0.03)';
            for (let i = 0; i < 8000; i++) ctx.fillRect(Math.random() * 1024, Math.random() * 1024, Math.random() * 200 + 50, Math.random() * 2 + 1);
            const tex = new THREE.CanvasTexture(cvs); tex.wrapS = tex.wrapT = THREE.RepeatWrapping; return tex;
        }

        // Exact CMRL Engine Face Silhouette mapping
        function createFaceTexture() {
            const cvs = document.createElement('canvas'); cvs.width = 1024; cvs.height = 1024;
            const ctx = cvs.getContext('2d');

            ctx.fillStyle = '#0065b3'; ctx.fillRect(0, 0, 1024, 1024); // Deep CMRL Blue

            // Giant swooping windshield
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.moveTo(80, 0); ctx.lineTo(944, 0);
            ctx.lineTo(880, 500);
            ctx.quadraticCurveTo(512, 850, 144, 500);
            ctx.fill();

            // Windshield wiper
            ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 12; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(512, 580); ctx.lineTo(300, 380); ctx.stroke();

            // Light housing indentations
            ctx.fillStyle = '#050505';
            ctx.beginPath(); ctx.ellipse(220, 750, 80, 45, Math.PI / 8, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(804, 750, 80, 45, -Math.PI / 8, 0, Math.PI * 2); ctx.fill();

            // CMRL Logo Decal (Mocked)
            ctx.fillStyle = '#dddddd'; ctx.beginPath(); ctx.arc(512, 600, 40, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#0065b3'; ctx.beginPath(); ctx.arc(512, 600, 25, 0, Math.PI * 2); ctx.fill();

            // Headlights are physical LEDs emitting bloom, drawn here just as placeholders
            return new THREE.CanvasTexture(cvs);
        }

        const M_STEEL = new THREE.MeshStandardMaterial({ color: 0xe5e7e9, map: createBrushedMetal(), roughness: 0.25, metalness: 0.9 });
        const M_BLUE_STRIPE = new THREE.MeshStandardMaterial({ color: 0x0065b3, roughness: 0.4, metalness: 0.3 });
        const M_DARK_METAL = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8, metalness: 0.5 });
        const M_CONCRETE = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.95, metalness: 0.05 });

        // Photorealistic Glass with Refraction & reflection
        const M_GLASS = new THREE.MeshPhysicalMaterial({
            color: 0x020202, metalness: 0.9, roughness: 0.0,
            transmission: 0.9, thickness: 1.5, ior: 1.52, // True glass physics
            transparent: true, opacity: 1.0, side: THREE.DoubleSide
        });

        const M_INTERIOR = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.9 });
        const M_SEAT = new THREE.MeshStandardMaterial({ color: 0x005ba1, roughness: 0.8 });
        const M_FACE = new THREE.MeshStandardMaterial({ map: createFaceTexture(), roughness: 0.2, metalness: 0.3 });

        // Extremely bright emissive materials for headlight Bloom
        const M_LED_WHITE = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 5.0 });
        const M_LED_RED = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 3.0 });

        // --- 4. PHOTOREALISTIC 2D HUMAN SPRITES ---
        // Instead of block shapes, we generate highly accurate 2D human silhouettes
        function createRealPassengerSprite() {
            const cvs = document.createElement('canvas'); cvs.width = 128; cvs.height = 256;
            const ctx = cvs.getContext('2d');

            // Realistic muted clothing colors
            const clothes = ['#444', '#345', '#533', '#111', '#555', '#224', '#665'];
            const hairColors = ['#0a0a0a', '#111', '#211'];

            // Body (clothing)
            ctx.fillStyle = clothes[Math.floor(Math.random() * clothes.length)];
            ctx.beginPath(); ctx.moveTo(35, 90);
            ctx.quadraticCurveTo(64, 70, 93, 90); // Shoulders
            ctx.lineTo(105, 256); ctx.lineTo(23, 256); ctx.fill(); // Torso dropping down

            // Neck / Skin
            ctx.fillStyle = '#b78b66'; // warm skin tone
            ctx.fillRect(56, 50, 16, 30);

            // Head
            ctx.fillStyle = hairColors[Math.floor(Math.random() * hairColors.length)];
            ctx.beginPath(); ctx.ellipse(64, 45, 18, 22, 0, 0, Math.PI * 2); ctx.fill();

            const tex = new THREE.CanvasTexture(cvs);
            tex.generateMipmaps = true; tex.minFilter = THREE.LinearMipmapLinearFilter;
            const mat = new THREE.SpriteMaterial({ map: tex });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(4.5, 9, 1);
            return sprite;
        }

        // --- 5. ULTRA-REALISTIC COACH ASSEMBLY ---
        function createCoach(isFront = false, isRear = false) {
            const coach = new THREE.Group();
            const length = 70;

            // Interior Shell
            const floor = new THREE.Mesh(new THREE.BoxGeometry(length, 1.5, 12), M_INTERIOR); floor.position.y = 0.75; coach.add(floor);
            const roof = new THREE.Mesh(new THREE.BoxGeometry(length, 1, 12), M_STEEL); roof.position.y = 13.5; coach.add(roof);

            // Outer Walls & Blue CMRL Stripe
            const lWall = new THREE.Mesh(new THREE.BoxGeometry(length, 5, 0.5), M_STEEL); lWall.position.set(0, 4, 5.75); coach.add(lWall);
            const rWall = new THREE.Mesh(new THREE.BoxGeometry(length, 5, 0.5), M_STEEL); rWall.position.set(0, 4, -5.75); coach.add(rWall);
            const lTop = new THREE.Mesh(new THREE.BoxGeometry(length, 2.5, 0.5), M_STEEL); lTop.position.set(0, 12.25, 5.75); coach.add(lTop);
            const rTop = new THREE.Mesh(new THREE.BoxGeometry(length, 2.5, 0.5), M_STEEL); rTop.position.set(0, 12.25, -5.75); coach.add(rTop);

            const sGeo = new THREE.BoxGeometry(length + 0.1, 1.4, 0.6);
            const s1 = new THREE.Mesh(sGeo, M_BLUE_STRIPE); s1.position.set(0, 5.2, 5.75); coach.add(s1);
            const s2 = new THREE.Mesh(sGeo, M_BLUE_STRIPE); s2.position.set(0, 5.2, -5.75); coach.add(s2);

            // True physically cutout Windows & Doors
            const doors = [-22, 0, 22];
            const gGeo = new THREE.PlaneGeometry(1, 5);
            let prevX = -35;
            for (let dx of doors) {
                let width = (dx - 2.5) - prevX; let cX = prevX + width / 2;
                if (width > 0) {
                    const g1 = new THREE.Mesh(gGeo, M_GLASS); g1.scale.x = width; g1.position.set(cX, 9.25, 5.95); coach.add(g1);
                    const g2 = new THREE.Mesh(gGeo, M_GLASS); g2.scale.x = width; g2.position.set(cX, 9.25, -5.95); g2.rotation.y = Math.PI; coach.add(g2);
                    // Silver pillar separators
                    const p1 = new THREE.Mesh(new THREE.BoxGeometry(2.5, 5.2, 0.5), M_STEEL); p1.position.set(dx - 3.5, 9.25, 5.75); coach.add(p1);
                    const p2 = new THREE.Mesh(new THREE.BoxGeometry(2.5, 5.2, 0.5), M_STEEL); p2.position.set(dx - 3.5, 9.25, -5.75); coach.add(p2);
                }

                // Detailed Passenger doors with warning frames
                const dFrame1 = new THREE.Mesh(new THREE.BoxGeometry(4.5, 9.5, 0.8), M_STEEL); dFrame1.position.set(dx, 6.25, 5.75); coach.add(dFrame1);
                const dFrame2 = new THREE.Mesh(new THREE.BoxGeometry(4.5, 9.5, 0.8), M_STEEL); dFrame2.position.set(dx, 6.25, -5.75); coach.add(dFrame2);
                const dg1 = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 4.5), M_GLASS); dg1.position.set(dx - 1, 8.5, 6.2); coach.add(dg1);
                const dg2 = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 4.5), M_GLASS); dg2.position.set(dx + 1, 8.5, 6.2); coach.add(dg2);
                const dgB1 = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 4), M_GLASS); dgB1.position.set(dx - 1, 8.5, -6.2); dgB1.rotation.y = Math.PI; coach.add(dgB1);
                const dgB2 = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 4), M_GLASS); dgB2.position.set(dx + 1, 8.5, -6.2); dgB2.rotation.y = Math.PI; coach.add(dgB2);
                prevX = dx + 2.5;
            }
            let width = 35 - prevX; let cX = prevX + width / 2;
            const gf1 = new THREE.Mesh(gGeo, M_GLASS); gf1.scale.x = width; gf1.position.set(cX, 9.25, 5.95); coach.add(gf1);
            const gf2 = new THREE.Mesh(gGeo, M_GLASS); gf2.scale.x = width; gf2.position.set(cX, 9.25, -5.95); gf2.rotation.y = Math.PI; coach.add(gf2);

            // Populating Interior (Real Passengers)
            for (let sx = -30; sx <= 30; sx += 10) {
                if (Math.abs(sx) < 5 || Math.abs(sx) === 20) continue; // Door gaps
                const s1 = new THREE.Mesh(new THREE.BoxGeometry(8, 1.5, 2.5), M_SEAT); s1.position.set(sx, 2.25, 4.25); coach.add(s1);
                const s2 = new THREE.Mesh(new THREE.BoxGeometry(8, 1.5, 2.5), M_SEAT); s2.position.set(sx, 2.25, -4.25); coach.add(s2);

                // Spawn completely realistic passenger silhouettes
                if (Math.random() > 0.3) {
                    let pax = createRealPassengerSprite(); pax.position.set(sx - 2, 5.5, 3.5); coach.add(pax);
                }
                if (Math.random() > 0.3) {
                    let pax2 = createRealPassengerSprite(); pax2.position.set(sx + 2, 5.5, -3.5); coach.add(pax2);
                }

                // Stainless steel pole & standing pax
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 12.5), new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 1.0, roughness: 0 }));
                pole.position.set(sx + 4.5, 7.5, 0); coach.add(pole);
                if (Math.random() > 0.6) {
                    let st = createRealPassengerSprite(); st.scale.set(5.5, 11, 1); st.position.set(sx + 4, 7, 1); coach.add(st);
                }
            }
            // Interior Glow Lights (Triggers external volumetric bloom through glass)
            for (let lx = -20; lx <= 20; lx += 20) {
                const plist = new THREE.PointLight(0xfff5e6, 0.6, 35);
                plist.position.set(lx, 11, 0); coach.add(plist);
            }

            // End Walls & Complex Aerodynamic Nose
            if (!isFront && !isRear) {
                const end1 = new THREE.Mesh(new THREE.BoxGeometry(1, 12, 11.5), M_DARK_METAL); end1.position.set(35, 7.5, 0); coach.add(end1);
                const end2 = new THREE.Mesh(new THREE.BoxGeometry(1, 12, 11.5), M_DARK_METAL); end2.position.set(-35, 7.5, 0); coach.add(end2);
            } else {
                const backE = new THREE.Mesh(new THREE.BoxGeometry(1, 12, 11.5), M_DARK_METAL);
                backE.position.set(isFront ? 35 : -35, 7.5, 0); coach.add(backE);

                // Sloped CMRL accurate Engine form
                const noseLen = 14;
                const noseGeo = new THREE.BoxGeometry(noseLen, 14, 12, 6, 6, 6);
                const pos = noseGeo.attributes.position;
                for (let i = 0; i < pos.count; i++) {
                    if (pos.getX(i) > 0) { // Mapping the forward face curvature
                        let y = pos.getY(i); let z = pos.getZ(i); let cx = pos.getX(i);
                        if (y > 0) cx -= y * 0.45; // Hard windshield curve backwards
                        let zTaper = Math.abs(z) / 5;
                        cx -= zTaper * 1.8; // Barrel nose shaping
                        pos.setX(i, cx);
                    }
                }
                noseGeo.computeVertexNormals();

                const nMats = [M_FACE, M_STEEL, M_BLUE_STRIPE, M_DARK_METAL, M_BLUE_STRIPE, M_BLUE_STRIPE];
                const nose = new THREE.Mesh(noseGeo, nMats);
                nose.position.set(isFront ? -42 : 42, 7.5, 0);
                if (isFront) nose.rotation.y = Math.PI;
                coach.add(nose);

                // LED Light Orbs embedded into the face driving the Unreal Bloom
                const ledLeft = new THREE.Mesh(new THREE.SphereGeometry(0.6), isFront ? M_LED_WHITE : M_LED_RED);
                ledLeft.position.set(isFront ? -47.2 : 47.2, 5.0, 3.8); coach.add(ledLeft);
                const ledRight = new THREE.Mesh(new THREE.SphereGeometry(0.6), isFront ? M_LED_WHITE : M_LED_RED);
                ledRight.position.set(isFront ? -47.2 : 47.2, 5.0, -3.8); coach.add(ledRight);
            }

            // Detailed Bogies & Physical Wheels
            const wheelGeo = new THREE.CylinderGeometry(2, 2, 1.5, 32); wheelGeo.rotateX(Math.PI / 2);
            if (!coach.userData) coach.userData = {}; coach.userData.wheels = [];

            for (let bx of [-23, 23]) {
                const bogie = new THREE.Group(); bogie.position.set(bx, -1.8, 0);
                const frame = new THREE.Mesh(new THREE.BoxGeometry(14, 2.5, 10.5), M_DARK_METAL); bogie.add(frame);
                for (let wx of [-4.5, 4.5]) {
                    for (let wz of [-5, 5]) {
                        const wheel = new THREE.Mesh(wheelGeo, M_STEEL); wheel.position.set(wx, -1, wz);
                        coach.userData.wheels.push(wheel); bogie.add(wheel);
                    }
                }
                // Air suspension bags
                const springGeo = new THREE.CylinderGeometry(1, 1, 3);
                for (let sz of [-5.5, 5.5]) {
                    const spring = new THREE.Mesh(springGeo, new THREE.MeshStandardMaterial({ color: 0x555 }));
                    spring.position.set(0, 1.5, sz); bogie.add(spring);
                }
                coach.add(bogie);
            }

            // Aerodynamic Roof AC Pods
            const ac = new THREE.Mesh(new THREE.BoxGeometry(16, 2.5, 9), M_STEEL);
            ac.position.set(0, 15, 0); coach.add(ac);

            return coach;
        }

        // --- 6. SCENE ASSEMBLY (TRAIN & BRIDGE) ---
        const envGroup = new THREE.Group(); scene.add(envGroup);
        // Concrete Flyover structure
        for (let i = -2; i <= 2; i++) {
            const bx = i * 200;
            const girder = new THREE.Mesh(new THREE.BoxGeometry(200, 5, 22), M_CONCRETE); girder.position.set(bx, 2.5, 0); envGroup.add(girder);
            const p1 = new THREE.Mesh(new THREE.BoxGeometry(200, 8, 1), M_CONCRETE); p1.position.set(bx, 9, 10.5); envGroup.add(p1);
            const p2 = new THREE.Mesh(new THREE.BoxGeometry(200, 8, 1), M_CONCRETE); p2.position.set(bx, 9, -10.5); envGroup.add(p2);

            const pillar = new THREE.Mesh(new THREE.CylinderGeometry(4.5, 5.5, 100, 16), M_CONCRETE);
            pillar.position.set(bx, -50, 0); envGroup.add(pillar);

            for (let s = -100; s < 100; s += 3) {
                const sleep = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.4, 18), M_DARK_METAL);
                sleep.position.set(bx + s, 5.2, 0); envGroup.add(sleep);
            }
            const r1 = new THREE.Mesh(new THREE.BoxGeometry(200, 0.8, 0.8), M_STEEL); r1.position.set(bx, 5.8, 4.8); envGroup.add(r1);
            const r2 = new THREE.Mesh(new THREE.BoxGeometry(200, 0.8, 0.8), M_STEEL); r2.position.set(bx, 5.8, -4.8); envGroup.add(r2);

            // Catenary Masts
            for (let cx = -75; cx <= 75; cx += 50) {
                const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 30), M_STEEL);
                mast.position.set(bx + cx, 20, -8.5); envGroup.add(mast);
                const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 12), M_STEEL);
                arm.position.set(bx + cx, 32, -3.5); arm.rotation.x = Math.PI / 2; envGroup.add(arm);
            }
            const wire = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 200), new THREE.MeshBasicMaterial({ color: 0x111 }));
            wire.position.set(bx, 32, 2); wire.rotation.z = Math.PI / 2; envGroup.add(wire);
        }

        // Deep Parallax City Background
        const cityGroup = new THREE.Group(); cityGroup.position.z = -200; scene.add(cityGroup);
        const bMat = new THREE.MeshStandardMaterial({ color: 0x4d7ea6, metalness: 0.2, roughness: 1, fog: true });
        for (let i = 0; i < 80; i++) {
            const h = 60 + Math.random() * 200;
            const b = new THREE.Mesh(new THREE.BoxGeometry(30 + Math.random() * 40, h, 30 + Math.random() * 30), bMat);
            b.position.set((Math.random() - 0.5) * 1200, h / 2 - 30, Math.random() * -200);
            cityGroup.add(b);
        }

        // Master Train Object
        const trainGroup = new THREE.Group();
        trainGroup.position.set(300, 10.5, 0);
        scene.add(trainGroup);

        const fEng = createCoach(true, false); trainGroup.add(fEng);
        const mCoach1 = createCoach(false, false); mCoach1.position.x = 74; trainGroup.add(mCoach1);
        const mCoach2 = createCoach(false, false); mCoach2.position.x = 148; trainGroup.add(mCoach2);
        const rEng = createCoach(false, true); rEng.position.x = 222; rEng.rotation.y = Math.PI; trainGroup.add(rEng);

        // Accordion Bellows
        const bellowMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.9 });
        const c1 = new THREE.Mesh(new THREE.BoxGeometry(4, 11, 10), bellowMat); c1.position.x = 37; trainGroup.add(c1);
        const c2 = new THREE.Mesh(new THREE.BoxGeometry(4, 11, 10), bellowMat); c2.position.x = 111; trainGroup.add(c2);
        const c3 = new THREE.Mesh(new THREE.BoxGeometry(4, 11, 10), bellowMat); c3.position.x = 185; trainGroup.add(c3);

        // Ready trigger
        document.getElementById('loading').style.opacity = '0';
        setTimeout(() => document.getElementById('loading').style.display = 'none', 1000);

        // --- 7. GENUINE SCROLL PHYSICS & RENDER LOOP ---
        const clock = new THREE.Clock();
        const state = { trainX: 300, camRotZ: 0 };

        let lastTrainX = 300;
        let pVelocity = 0;
        let bobPhase = 0;

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);

            // Base Train and Parallax Position
            trainGroup.position.x = state.trainX;
            cityGroup.position.x = (state.trainX * -0.15);

            // True Physics engine: Reading dx/dt from GSAP scroll delta
            let velocityRaw = 0;
            if (dt > 0) velocityRaw = (state.trainX - lastTrainX) / dt;
            const speed = Math.abs(velocityRaw);

            pVelocity += (velocityRaw - pVelocity) * 0.1;
            lastTrainX = state.trainX;

            // Real Train Mass Simulation
            if (speed > 2) {
                // Pitch: Sudden acceleration rips the nose upwards
                const pitch = (velocityRaw - pVelocity) * 0.0007;

                // Track Vibration (Bobs faster as speed increases)
                bobPhase += speed * dt * 0.15;
                const rumble = Math.max(0.05, speed / 120);

                fEng.position.y = Math.sin(bobPhase) * rumble; fEng.rotation.z = pitch;
                mCoach1.position.y = Math.sin(bobPhase + 1) * rumble; mCoach1.rotation.z = pitch;
                mCoach2.position.y = Math.sin(bobPhase + 2) * rumble; mCoach2.rotation.z = pitch;
                rEng.position.y = Math.sin(bobPhase + 3) * rumble; rEng.rotation.z = -pitch;

                // Unison Wheel Rotation locked to distance traveled
                const rotDelta = (state.trainX - lastTrainX) * 0.5;
                [fEng, mCoach1, mCoach2, rEng].forEach(coach => {
                    if (coach.userData.wheels) coach.userData.wheels.forEach(w => w.rotation.x -= rotDelta);
                });

            } else {
                // Settle Physics when stopped
                fEng.position.y += (0 - fEng.position.y) * 0.1; fEng.rotation.z *= 0.8;
                mCoach1.position.y += (0 - mCoach1.position.y) * 0.1; mCoach1.rotation.z *= 0.8;
                mCoach2.position.y += (0 - mCoach2.position.y) * 0.1; mCoach2.rotation.z *= 0.8;
                rEng.position.y += (0 - rEng.position.y) * 0.1; rEng.rotation.z *= 0.8;
            }

            // Camera tracks the train globally for the cinematic shots
            camera.position.x += ((state.trainX + 30) - camera.position.x) * 0.05;

            // The camera Z is animated by GSAP. Y is fixed via GSAP.
            // Look exactly at the train's window height.
            // This strictly crops out the wheels at high zoom.
            camera.lookAt(state.trainX, 18, 0);
            camera.rotation.z = state.camRotZ;

            // Render via EffectComposer (Bloom applied)
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 8. GSAP CINEMATIC SCROLL ORCHESTRATION ---
        const tl = gsap.timeline({
            scrollTrigger: { trigger: "body", start: "top top", end: "bottom bottom", scrub: 1.5 }
        });

        tl.to("#ui", { opacity: 0, duration: 0.5, ease: "power2.in" }, 0);

        // Tilt camera down to ground level
        tl.to(camera.position, { y: 18, z: 90, duration: 2, ease: "power3.inOut" }, 0);

        // Massive leftward traversal (train speed)
        tl.to(state, { trainX: -900, duration: 8, ease: "power2.inOut" }, 1);

        // EXTREME SHREDDING: The camera physically zooms in directly to window height Y=18. 
        // At Z=35, the lower bounds of the FOV cleanly cut off before reaching the Y=9 wheel level!
        tl.to(camera.position, { z: 35, duration: 3, ease: "power1.inOut" }, 3);

        // Add CSS Shutter letterboxing for the final cinematic framing
        tl.to(".shutter", { height: "25vh", duration: 1, ease: "power2.out" }, 4); // Leaves 50vh visible
        tl.to(state, { camRotZ: 0.05, duration: 2, ease: "sine.inOut" }, 5); // Add visceral camera dutch angle tilt

    </script>
</body>

</html>